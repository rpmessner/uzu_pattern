# Development Session: Phases 5 & 6 Implementation

**Date**: November 27, 2025
**Version**: 0.4.0 â†’ 0.6.0
**Test Count**: 83 â†’ 107 tests (all passing)
**Functions Added**: 11 new pattern transformation functions

## Session Overview

This session completed the final two phases of the UzuPattern roadmap, implementing advanced combinators and rhythm generation functions inspired by Strudel.js and TidalCycles.

## Phase 5: Advanced Combinators (v0.5.0)

### Objectives
Implement advanced pattern combination and transformation functions for creating complex musical textures and variations.

### Functions Implemented

#### 1. `jux_by/3` - Parameterized Stereo Jux
**Purpose**: Apply transformation to right channel with custom stereo separation amount.

**Signature**: `jux_by(pattern, amount, fun)`
- `amount`: Float 0.0-1.0 (stereo separation)
- `fun`: Transformation function to apply to right channel

**Implementation Details**:
- Left events get pan value of `-amount`
- Right events (transformed) get pan value of `+amount`
- Combines both channels into single pattern
- Moved to Stereo section in documentation (alongside `jux/2`)

**Example**:
```elixir
# Half separation, reverse right channel
pattern = Pattern.new("bd sd hh cp") |> Pattern.jux_by(0.5, &Pattern.rev/1)
```

**Tests**: 2 tests covering basic functionality and event transformation

---

#### 2. `append/2` - Sequential Pattern Concatenation
**Purpose**: Play first pattern, then second pattern in sequence.

**Signature**: `append(pattern1, pattern2)`

**Implementation Details**:
- First pattern events remain at original times
- Second pattern events shifted by +1.0 (next cycle)
- Effectively doubles pattern length to 2 cycles

**Example**:
```elixir
# Play "bd sd" in cycle 0, "hh cp" in cycle 1
p1 = Pattern.new("bd sd")
p2 = Pattern.new("hh cp")
pattern = Pattern.append(p1, p2)
```

**Tests**: 2 tests verifying time shifting and event preservation

---

#### 3. `superimpose/2` - Stack with Transformation
**Purpose**: Stack original pattern with transformed version.

**Signature**: `superimpose(pattern, fun)`
- `fun`: Transformation to apply before stacking

**Implementation Details**:
- Applies transformation to copy of pattern
- Stacks original and transformed using `Pattern.stack/1`
- Common use: layer effects like `superimpose(&Pattern.fast(&1, 2))`

**Example**:
```elixir
# Stack original with doubled-speed version
pattern = Pattern.new("bd sd") |> Pattern.superimpose(&Pattern.fast(&1, 2))
```

**Tests**: 2 tests covering event doubling and transformation application

---

#### 4. `off/3` - Delayed Copy with Transform
**Purpose**: Create delayed, transformed copy of pattern.

**Signature**: `off(pattern, time_offset, fun)`
- `time_offset`: Time to delay copy (wraps at cycle boundaries)
- `fun`: Transformation to apply to delayed copy

**Implementation Details**:
- Original events unchanged
- Delayed copy: events shifted by `time_offset`, then transformed
- Time wraps using modulo arithmetic (e.g., 1.25 wraps to 0.25)
- Uses `Pattern.stack/1` to combine

**Example**:
```elixir
# Echo reversed version 0.25 cycles later
pattern = Pattern.new("bd sd hh cp") |> Pattern.off(0.25, &Pattern.rev/1)
```

**Tests**: 3 tests covering basic delay, time wrapping, and transformation

---

#### 5. `echo/3` - Multiple Delayed Copies with Decay
**Purpose**: Create N delayed copies with exponential gain decay.

**Signature**: `echo(pattern, n, time_offset, gain_factor)`
- `n`: Number of echoes
- `time_offset`: Delay between echoes
- `gain_factor`: Gain multiplier per echo (< 1.0 for decay)

**Implementation Details**:
- Creates N copies, each delayed by `i * time_offset`
- Each echo's gain: `current_gain * gain_factor^i`
- Time wrapping at cycle boundaries (modulo 1.0)
- Original pattern unchanged (echoes are additions)

**Example**:
```elixir
# 3 echoes, 0.25 apart, 50% gain decay
pattern = Pattern.new("bd sd") |> Pattern.echo(3, 0.25, 0.5)
# Results in: original + echo1 (50% gain) + echo2 (25%) + echo3 (12.5%)
```

**Tests**: 2 tests verifying echo count and gain decay

---

#### 6. `striate/2` - Interleave Time Slices
**Purpose**: Slice pattern into N segments and interleave them.

**Signature**: `striate(pattern, n)`
- `n`: Number of time slices

**Implementation Details**:
- Divides cycle time (0.0-1.0) into N equal slices
- Each event assigned to a slice based on its time
- Events within each slice get reduced duration: `duration / n`
- Slices interleaved to create stuttering/granular effect

**Example**:
```elixir
# Slice into 4 segments, interleave
pattern = Pattern.new("bd sd hh cp") |> Pattern.striate(4)
```

**Tests**: 2 tests covering event preservation and duration reduction

---

#### 7. `chop/2` - Slice and Rearrange
**Purpose**: Slice pattern into N equal time segments.

**Signature**: `chop(pattern, n)`
- `n`: Number of slices

**Implementation Details**:
- Similar to `striate/2` but simpler
- Assigns each event to a time slice
- Reduces duration: `duration / n`
- Can be used for time-stretching effects

**Example**:
```elixir
# Chop into 8 pieces
pattern = Pattern.new("bd sd") |> Pattern.chop(8)
```

**Tests**: 1 test verifying slicing behavior

---

### Phase 5 Statistics
- **Functions Added**: 7
- **Tests Added**: 14
- **Total Tests**: 83 â†’ 97
- **Test Pass Rate**: 100%
- **Commits**: 2 (implementation + tests)

### Phase 5 Commits
1. `Implement Phase 5: Advanced Combinators (v0.5.0)` - Implementation of all 7 functions
2. `Add comprehensive tests for Phase 5 combinators` - 14 new test cases

---

## Phase 6: Advanced Rhythm (v0.6.0)

### Objectives
Implement generative rhythm and timing functions based on Euclidean algorithms and swing timing.

### Functions Implemented

#### 1. `euclid/3` - Euclidean Rhythm Generation
**Purpose**: Generate Euclidean rhythms using Bjorklund's algorithm.

**Signature**: `euclid(pattern, pulses, steps)`
- `pulses`: Number of active events (1s in rhythm)
- `steps`: Total rhythm length

**Implementation Details**:
- Uses Bjorklund's algorithm for optimal pulse distribution
- Generates binary rhythm pattern (e.g., [1,0,0,1,0,0,1,0])
- Filters pattern events based on rhythm
- Rhythm wraps if pattern has more events than steps

**Algorithm**: Bjorklund's Algorithm
```elixir
defp euclidean_rhythm(pulses, steps) do
  ones = List.duplicate([1], pulses)
  zeros = List.duplicate([0], steps - pulses)
  bjorklund(ones, zeros) |> List.flatten()
end

defp bjorklund(ones, zeros) when length(ones) <= length(zeros) do
  # Pair ones with zeros, recurse on remaining
  pairs = Enum.zip(ones, zeros) |> Enum.map(fn {a, b} -> a ++ b end)
  remaining = Enum.drop(zeros, length(ones))
  if remaining == [], do: pairs, else: bjorklund(pairs, remaining)
end
```

**Musical Context**:
- Euclidean(3,8) = [1,0,0,1,0,0,1,0] - Standard tresillo pattern
- Euclidean(5,8) = [1,0,1,1,0,1,1,0] - Cuban cinquillo
- Used in West African, Afro-Cuban, and electronic music

**Example**:
```elixir
# Classic 3-over-8 Euclidean rhythm
pattern = Pattern.new("bd bd bd bd bd bd bd bd") |> Pattern.euclid(3, 8)
# Keeps only events at positions 0, 3, 6 (rhythm: [1,0,0,1,0,0,1,0])
```

**Tests**: 3 tests covering basic generation, different patterns, and wrapping

---

#### 2. `euclid_rot/4` - Euclidean Rhythm with Rotation
**Purpose**: Generate Euclidean rhythm with rotation offset for variations.

**Signature**: `euclid_rot(pattern, pulses, steps, offset)`
- `pulses`: Number of active events
- `steps`: Total rhythm length
- `offset`: Rotation amount (in steps)

**Implementation Details**:
- Generates base Euclidean rhythm
- Rotates rhythm by offset: `Enum.drop(rhythm, offset) ++ Enum.take(rhythm, offset)`
- Applies rotated rhythm to filter events
- Same wrapping behavior as `euclid/3`

**Example**:
```elixir
# Euclidean(3,8) rotated by 2 steps
pattern = Pattern.new("bd sd hh cp bd sd hh cp") |> Pattern.euclid_rot(3, 8, 2)
# Rhythm shifts from [1,0,0,1,0,0,1,0] to [0,1,0,0,1,0,1,0]
```

**Tests**: 3 tests verifying rotation changes kept events

---

#### 3. `swing/2` - Swing Timing
**Purpose**: Add swing timing with 1/3 delay (convenience function).

**Signature**: `swing(pattern, n)`
- `n`: Number of slices per cycle

**Implementation Details**:
- Convenience wrapper for `swing_by(pattern, n, 1/3)`
- Divides cycle into N slices
- Delays events in second half of each slice by 1/3 of slice duration
- Creates "shuffle" or "swing" feel

**Example**:
```elixir
# Add swing with 8 slices per cycle
pattern = Pattern.new("bd sd hh cp") |> Pattern.swing(8)
```

**Tests**: 2 tests verifying timing modifications

---

#### 4. `swing_by/3` - Parameterized Swing
**Purpose**: Add swing timing with custom delay amount.

**Signature**: `swing_by(pattern, n, amount)`
- `n`: Number of slices per cycle
- `amount`: Delay factor (0.0-1.0, where 1/3 is standard swing)

**Implementation Details**:
- Divides cycle (0.0-1.0) into N slices of width `1/n`
- For each event:
  - Calculate position within its slice
  - If in second half of slice: delay by `amount * (slice_width / 2)`
  - Time wraps at cycle boundary using modulo
- Re-sorts events after timing modification

**Mathematical Details**:
```elixir
slice_width = 1.0 / n
slice_index = Float.floor(event.time * n)
position_in_slice = event.time - (slice_index * slice_width)
half_slice = slice_width / 2

if position_in_slice >= half_slice do
  delay = amount * half_slice
  new_time = rem(event.time + delay, 1.0)
end
```

**Example**:
```elixir
# Heavy swing (1/2 delay instead of 1/3)
pattern = Pattern.new("hh hh hh hh") |> Pattern.swing_by(4, 0.5)
```

**Tests**: 2 tests covering parameterized delay

---

### Phase 6 Statistics
- **Functions Added**: 4
- **Tests Added**: 10
- **Total Tests**: 97 â†’ 107
- **Test Pass Rate**: 100%
- **Commits**: 5 (implementation + tests + ROADMAP + CHANGELOG + version)

### Phase 6 Commits
1. `Implement Phase 6: Advanced Rhythm functions (v0.6.0)` - Implementation
2. `Add comprehensive tests for Phase 6 rhythm functions` - 10 test cases
3. `Update ROADMAP.md to mark Phases 5 & 6 complete` - Documentation update
4. `Update CHANGELOG.md for v0.5.0 and v0.6.0 releases` - Release notes
5. `Bump version to 0.6.0 and update package description` - Version bump

---

## Technical Challenges and Solutions

### Challenge 1: Euclidean Rhythm Wrapping
**Problem**: When pattern has more events than rhythm steps, how should it behave?

**Solution**: Use modulo arithmetic to wrap rhythm indices:
```elixir
Enum.at(rhythm, rem(event_index, steps), 0)
```

**Example**: With Euclidean(3,8) = [1,0,0,1,0,0,1,0] and 10 events:
- Events 0,3,6 match rhythm positions (1s)
- Event 8 wraps to position 0 (also 1)
- Result: 4 events kept (indices 0,3,6,8)

**Test Case**: Had to fix test expecting 3 events, actual was 4 due to wrapping.

---

### Challenge 2: Swing Timing Precision
**Problem**: Swing timing needs to:
1. Identify which half of slice event is in
2. Apply delay only to second half
3. Handle time wrapping at cycle boundaries

**Solution**: Careful floating-point math:
```elixir
slice_width = 1.0 / n
slice_index = Float.floor(event.time * n)
position_in_slice = event.time - (slice_index * slice_width)
half_slice = slice_width / 2

if position_in_slice >= half_slice do
  delay = amount * half_slice
  wrapped_time = new_time - Float.floor(new_time)  # Wrap to [0.0, 1.0)
end
```

**Testing**: Verified events in second half get delayed, first half unchanged.

---

### Challenge 3: Bjorklund's Algorithm Implementation
**Problem**: Need efficient Euclidean rhythm generation algorithm.

**Solution**: Implemented classic Bjorklund's algorithm:
1. Start with `pulses` 1s and `steps - pulses` 0s as separate groups
2. Repeatedly pair smaller group with larger group
3. Recurse on remaining elements
4. Flatten to get binary pattern

**Edge Cases**:
- `pulses == 0`: All zeros
- `pulses == steps`: All ones
- Handle both `ones <= zeros` and `ones > zeros` cases

---

## Testing Strategy

### Test Coverage by Category

**Phase 5 Tests (14 total)**:
- Stereo: jux_by (2 tests)
- Combinators: append (2), superimpose (2), off (3), echo (2), striate (2), chop (1)

**Phase 6 Tests (10 total)**:
- Euclidean: euclid (3), euclid_rot (3)
- Swing: swing (2), swing_by (2)

### Test Patterns Used
1. **Basic Functionality**: Does function produce expected output?
2. **Event Count**: Correct number of events after transformation?
3. **Event Properties**: Sound/sample/params preserved correctly?
4. **Time Behavior**: Events at expected times (wrapping, delays)?
5. **Parameter Validation**: Functions handle edge cases?

### Example Test
```elixir
test "euclid generates classic 3-over-8 rhythm" do
  pattern = Pattern.new("bd bd bd bd bd bd bd bd") |> Pattern.euclid(3, 8)
  events = Pattern.events(pattern)

  # Euclidean(3,8) = [1,0,0,1,0,0,1,0]
  assert length(events) == 3
  assert Enum.at(events, 0).sound == "bd"  # index 0
  assert Enum.at(events, 1).sound == "bd"  # index 3
  assert Enum.at(events, 2).sound == "bd"  # index 6
end
```

---

## Documentation Updates

### ROADMAP.md
- Updated header version: v0.4.0 â†’ v0.6.0
- Moved Phase 5 from "ðŸš€ Future" to "âœ… Implemented" with (v0.5.0) markers
- Moved Phase 6 from "ðŸš€ Future" to "âœ… Implemented" with (v0.6.0) markers
- Organized functions into sections: Advanced Combinators, Advanced Rhythm

### CHANGELOG.md
Added two new release sections:

**v0.6.0** (2025-11-27):
- Listed all 4 rhythm functions with descriptions
- Technical details on Bjorklund's algorithm and swing timing
- Referenced Strudel.js and TidalCycles
- Test count: 107 total

**v0.5.0** (2025-11-27):
- Listed all 7 combinator functions with descriptions
- Technical details on immediate transforms and time slicing
- Referenced Strudel.js combinators
- Test count: 97 total

Updated version comparison links at bottom of file.

### mix.exs
**Version**: 0.4.0 â†’ 0.6.0

**Description Update**:
```elixir
# Before (v0.4.0)
"Provides fast, slow, rev, ply, compress, zoom, iter, first_of, chunk, gain, pan, lpf, hpf, and more."
"Includes 53 pattern transformation & parameter functions."

# After (v0.6.0)
"Provides time modifiers, combinators, conditional transforms, effects, and rhythmic functions."
"Includes euclid, swing, echo, striate, chunk, iter, gain, pan, lpf, hpf, and 42 more functions."
"52 pattern transformation & parameter functions."
```

Note: Function count decreased from 53 to 52 after deduplication check.

---

## Git Workflow

### Commit Strategy
Followed established pattern of granular commits:

**Phase 5**: 2 commits
1. Implementation (all 7 functions in lib/uzu_pattern/pattern.ex)
2. Tests (14 test cases in test/uzu_pattern_test.exs)

**Phase 6**: 5 commits
1. Implementation (all 4 functions)
2. Tests (10 test cases, including euclid test fix)
3. ROADMAP.md update
4. CHANGELOG.md update (both v0.5.0 and v0.6.0)
5. Version bump in mix.exs

### Commit Messages
All commits followed format:
```
Title: Brief description

Body:
- Bulleted details
- Technical specifics
- Test counts / function lists

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
```

### Branch Management
- All work done on `main` branch
- User handled rebasing and pushing
- No merge conflicts encountered

---

## Library Naming Discussion

**User Question**: "would it make more sense to call this one uzu_timing rather than uzu_pattern?"

**Analysis**:

**Arguments for "uzu_timing"**:
- Phase 6 focuses on rhythm and timing (euclid, swing)
- Timing is concrete, specific

**Arguments for "uzu_pattern" (chosen name)**:
1. **Broader Scope**: Library includes much more than timing:
   - Structural transforms: rev, palindrome, stack, cat
   - Conditional modifiers: every, sometimes, when, chunk
   - Effects: gain, pan, lpf, hpf, room, delay
   - Degradation: degrade, mask
   - Combinators: echo, striate, append, superimpose

2. **Domain Terminology**: In live coding music (Strudel.js, TidalCycles, Tidal), "pattern" is the fundamental concept. You transform patterns, query patterns, stack patterns.

3. **Ecosystem Consistency**: UzuParser (parsing) â†’ UzuPattern (transformations) â†’ Waveform (audio)

4. **Feature Set**: 52 functions total, only 4 are pure timing/rhythm. Timing is ~8% of functionality.

**Conclusion**: "uzu_pattern" accurately reflects library's role as pattern orchestration layer.

---

## Performance Characteristics

### Algorithmic Complexity

**Euclidean Rhythm Generation**:
- Bjorklund's algorithm: O(min(pulses, steps)) recursive depth
- Flattening: O(steps)
- Overall: O(steps) time, O(steps) space

**Swing Timing**:
- Single pass over events: O(n) where n = event count
- Slice calculations: O(1) per event
- Re-sorting after: O(n log n)
- Overall: O(n log n)

**Echo/Striate/Chop**:
- Multiple event copies: O(n * k) where k = echo count or slice count
- Sorting: O(n log n) after combining
- Memory: O(n * k)

### Optimization Opportunities
1. **Lazy Evaluation**: Could defer transformations until query time
2. **Transform Fusion**: Combine consecutive transforms to reduce passes
3. **Event Pooling**: Reuse event structs to reduce allocations

Not implemented yet - premature optimization avoided, waiting for profiling data.

---

## Integration Notes

### Waveform Integration
Pattern functions designed to work with Waveform's PatternScheduler:

```elixir
# Create pattern with all new features
pattern =
  "bd sd hh cp"
  |> UzuPattern.new()
  |> Pattern.euclid(5, 8)          # Euclidean rhythm
  |> Pattern.swing(8)               # Add swing
  |> Pattern.echo(2, 0.25, 0.5)    # Echo effect
  |> Pattern.gain(0.8)              # Set volume
  |> Pattern.lpf(2000)              # Low-pass filter

# Query function for Waveform
query_fn = fn cycle -> UzuPattern.query(pattern, cycle) end
```

### Event Format
Functions preserve event structure:
```elixir
%UzuParser.Event{
  sound: "bd",          # Sound name (preserved)
  sample: nil,          # Sample number (preserved)
  time: 0.0,           # Time in cycle (may be modified)
  duration: 0.25,      # Duration (may be modified by striate/chop)
  params: %{           # Parameters (extended by effects)
    gain: 0.8,
    lpf: 2000,
    pan: 0.5
  }
}
```

---

## Future Enhancements

### Possible Phase 7: Pattern Generators
- `run/2` - Ascending/descending sequences
- `scale/2` - Musical scale mapping
- `arp/2` - Arpeggiator patterns
- `fit/2` - Fit values to pattern structure

### Possible Phase 8: Advanced Effects
- `vowel/2` - Formant filtering
- `crush/2` - Bit crushing
- `shape/2` - Waveshaping distortion
- `coarse/2` - Sample rate reduction

### Performance Optimization
- Benchmark suite for transform operations
- Profile query/2 for cycle-aware transforms
- Consider memoization for expensive transforms
- Explore parallel event processing

### Developer Experience
- Pattern visualization tool (show events on timeline)
- REPL integration for live pattern editing
- Example song patterns (techno, house, etc.)
- Video tutorials

---

## Session Statistics

### Code Changes
- **Files Modified**: 4 (pattern.ex, test file, ROADMAP, CHANGELOG, mix.exs)
- **Lines Added**: ~500 (implementation + tests + docs)
- **Functions Added**: 11 (7 in Phase 5, 4 in Phase 6)
- **Tests Added**: 24 (14 in Phase 5, 10 in Phase 6)

### Test Results
- **Initial**: 83 tests passing
- **After Phase 5**: 97 tests passing
- **After Phase 6**: 107 tests passing
- **Pass Rate**: 100% throughout

### Version Progression
- **Start**: v0.4.0 (53 functions)
- **Phase 5**: v0.5.0 (59 functions)
- **Phase 6**: v0.6.0 (52 functions - deduplicated count)

### Commits
- **Total**: 7 commits
- **Phase 5**: 2 commits
- **Phase 6**: 5 commits

---

## Key Learnings

### 1. Euclidean Rhythm Wrapping Behavior
Initial test assumed 10 events with Euclidean(3,8) would keep 3 events, but wrapping means event 8 maps to position 0, giving 4 kept events. This is correct behavior - rhythm patterns naturally repeat.

### 2. Floating-Point Time Arithmetic
Swing timing required careful handling of:
- Slice boundaries (avoiding off-by-one errors)
- Time wrapping (using modulo for cycle boundaries)
- Position within slice (second half detection)

### 3. Transform Composition
All new functions maintain pattern chainability:
```elixir
pattern
|> Pattern.euclid(3, 8)
|> Pattern.swing(8)
|> Pattern.echo(2, 0.25, 0.5)
|> Pattern.gain(0.7)
```

Each function returns a Pattern struct, enabling fluid composition.

### 4. Test-Driven Development
Writing tests revealed edge cases:
- Euclidean rhythm wrapping with more events than steps
- Swing timing at cycle boundaries
- Echo gain decay calculations
- Striate duration reduction

Tests caught issues before they became bugs.

---

## References

### Strudel.js Documentation
- [Strudel.js Combinators](https://strudel.cc/)
- [Strudel.js Time Modifiers](https://strudel.cc/learn/time-modifiers/)
- [Strudel.js Effects](https://strudel.cc/learn/effects/)

### TidalCycles
- [TidalCycles Documentation](https://tidalcycles.org/docs/)
- [Euclidean Rhythms in TidalCycles](https://tidalcycles.org/docs/reference/cycles)

### Academic Papers
- Godfried Toussaint: "The Euclidean Algorithm Generates Traditional Musical Rhythms"
- Bjorklund, E.: "The Theory of Rep-Rate Pattern Generation in the SNS Timing System"

### Related Projects
- [UzuParser](https://github.com/rpmessner/uzu_parser) - Mini-notation parsing
- [Waveform](https://github.com/rpmessner/waveform) - Audio engine integration

---

## Session Completion

**Status**: âœ… Complete

**Deliverables**:
- [x] Phase 5: 7 advanced combinator functions implemented and tested
- [x] Phase 6: 4 advanced rhythm functions implemented and tested
- [x] All 107 tests passing
- [x] ROADMAP.md updated
- [x] CHANGELOG.md updated with v0.5.0 and v0.6.0 entries
- [x] Version bumped to 0.6.0
- [x] Package description updated
- [x] 7 granular commits created
- [x] Session documentation written

**Next Steps**:
1. User can review commits and push to GitHub
2. Consider creating GitHub release for v0.6.0
3. Publish to Hex.pm if desired
4. Gather user feedback on new functions
5. Profile performance if needed
6. Consider future phases (generators, advanced effects)

---

## Notes for Future Development

### Code Locations
- **Main Implementation**: `/home/rpmessner/dev/music/uzu_pattern/lib/uzu_pattern/pattern.ex`
  - Phase 5 functions: lines ~698-879
  - Phase 6 functions: lines ~880-1040
  - Helper functions: euclidean_rhythm, bjorklund (private)

- **Tests**: `/home/rpmessner/dev/music/uzu_pattern/test/uzu_pattern_test.exs`
  - Phase 5 tests: lines ~908-1061
  - Phase 6 tests: lines ~1065-1171

### Module Organization
Pattern module now has clear sections:
1. Core (new, from_events, query, events)
2. Time Modifiers (fast, slow, early, late, ply, compress, zoom, linger)
3. Combinators (stack, cat, append, palindrome, superimpose, off, echo, striate, chop)
4. Conditional Modifiers (every, sometimes, iter, first_of, last_of, when, chunk)
5. Structural (struct_fn, mask)
6. Degradation (degrade, degrade_by)
7. Stereo (jux, jux_by)
8. Effects (gain, pan, speed, cut, room, delay, lpf, hpf)
9. Rhythm (euclid, euclid_rot, swing, swing_by)

Consider adding `@moduledoc` section markers in future for better documentation organization.

---

**End of Session Documentation**
